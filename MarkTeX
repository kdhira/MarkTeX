#!/usr/bin/env python3

import os
import sys
import re
import math
VERSION='v0.2'
CONFIGEXT = '.mtconfig'

class MarkTex:
    def __init__(self):
        self.macros = {}
        self.defaultvars = {}
        self.documents = []
        macrotypes = ['preamble', 'document']

        dir = os.path.expanduser('~/.MarkTeX/')
        if not os.path.exists(dir):
            os.makedirs(dir)

        for macrotype in macrotypes:
            self.macros[macrotype] = {}
            macromapfile = dir + macrotype + CONFIGEXT
            if os.path.isfile(macromapfile):
                with open(macromapfile, 'r') as fr:
                    for line in fr:
                        if line.startswith('#') or not ':' in line:
                            continue

                        key, val = line.split(':', 1)
                        key, val = key.strip(), val.strip()
                        if key != '':
                            self.macros[macrotype][key] = val
            elif not os.path.exists(macromapfile):
                open(macromapfile, 'x').close()


        defaultvarsfile = dir + 'defaults' + CONFIGEXT
        if os.path.isfile(defaultvarsfile):
            with open(defaultvarsfile, 'r') as fr:
                for line in fr:
                    if line.startswith('#') or not ':' in line:
                        continue

                    key, val = line.split(':', 1)
                    key, val = key.strip(), val.strip()
                    if key != '':
                        self.defaultvars[key] = val


class LatexDocument:
    def __init__(self, inputFile, mtx):
        self.marktex = mtx
        self.content = ''
        self.preamble = ''
        self.vars = mtx.defaultvars.copy()
        self.inputFile = inputFile

        try:
            self.fr = open(inputFile, 'r')
        except Exception as e:
            print(str(e))

    def findall(self, text, pattern):
        return [m.start(0) for m in re.finditer('(?='+pattern+')', text)]

    def replaceText(self, source, start, length, text):
        if start+length > len(source):
            return source[:start] + text

        return source[:start] + text + source[start+length:]

    def addVariable(self, key, value):
        self.vars[key] = value

    def appendPreamble(self, text):
        self.preamble = self.preamble + text

    def appendContent(self, text):
        self.content = self.content + text

    def readFrontMatter(self):
        if self.fr.readline().rstrip() != '---':
            print("Error: Front matter started expected; not found.")
            sys.exit(3)

        while True:
            line = self.fr.readline();
            if line == '':
                print("Error: EOF before front matter end.")
                sys.exit(4)

            line = line.rstrip()
            if line == '---':
                break

            if not line.startswith('#') and ':' in line:
                key,val = line.split(':', 1)
                key = key.strip()
                val = val.strip()
                if key != '':
                    self.addVariable(key, val)



    def writeVariables(self):
        self.appendPreamble('\\documentclass[10pt,a4paper]{article}\n')
        documentKeys = {k:v for k,v in self.vars.items() if k.startswith('document.')}

        for v in ['title', 'author', 'date']:
            if v in self.vars:
                self.appendPreamble('\\' + v + '{' + self.vars[v] + '}\n')

        map = {
            'preamble': self.appendPreamble,
            'document': self.appendContent
        }
        for m,f in map.items():
            for k in {k:v for k,v in self.vars.items() if k.startswith(m + '.') and v in ['1', 'True', 'true', 'yes', 'Yes']}:
                f(self.marktex.macros[m][k.partition('.')[2]] + '\n')

    def writeContent(self):
        raw = False

        line = self.fr.readline()
        while line != '':
            rawline = line
            line = line.rstrip()
            if raw:
                if line == '\\end{latex}':
                    raw = False
                else:
                    self.appendContent(line + '\n')
            else:
                if line == '\\begin{latex}':
                    raw = True
                elif line == '\\end{latex}':
                    raw = False
                elif line.startswith('#'):
                    self.addHeading(line)
                else:
                    self.appendContent(self.processText(rawline) + '\n')

            line = self.fr.readline()

    def processText(self, text):
        text = text.rstrip('\n')

        patterns = [];
        patterns.append((r'[\*]{3}', '***', '\\textbf{\\textit{', '}}'))
        patterns.append((r'[_]{3}', '___', '\\textbf{\\textit{', '}}'))
        patterns.append((r'[\*]{2}', '**', '\\textbf{', '}'))
        patterns.append((r'[_]{2}', '__', '\\textbf{', '}'))
        patterns.append((r'[\*]{1}', '*', '\\textit{', '}'))
        patterns.append((r'[_]{1}', '_', '\\textit{', '}'))
        patterns.append((r'[`]{1}', '`', '\\texttt{', '}'))

        for p,r,s,e in patterns:
            m = self.findall(text, p)
            for i in m:
                if i > 0 and text[i-1] in '\\\0':
                    m.remove(i)
                    text = self.replaceText(text, i-1, 1, '\0')
            alt = [s,e]
            for i in range(len(m)//2*2-1, -1, -1):
                text = self.replaceText(text, m[i], len(r), alt[i%2])

        return self.escapeCharacters(text)

    def escapeCharacters(self, text):
        toDelete = []
        i = 0
        while i < len(text):
            if text[i] == '\0':
                if i + 1 < len(text) and text[i:i+2] == '\\\\':
                    break
                toDelete.append(i)
                i += 1
            i += 1

        text = ''.join([text[i] for i in range(len(text)) if not i in toDelete])

        if text.endswith('  '):
            text = self.replaceText(text, len(text)-2, 2, '\\\\')

        return text.strip();

    def addHeading(self, line):
        depth = 0
        for i in range(3, 0, -1):
            if line.startswith(i*'#'):
                depth = i
                break

        self.appendContent('\\'+ (depth-1)*'sub' + 'section{' + self.processText(line[depth:]) + '}\n')

    def combineDocument(self):
        return self.preamble \
            + '\n\\begin{document}\n\n' \
            + self.content \
            + '\n\\end{document}\n'

    def writeDocument(self):
        if not '.' in self.inputFile:
            newFile = self.inputFile + '.tex'
        else:
            newFile = self.inputFile.rsplit('.', 1)[0] + '.tex'


        with open(newFile, 'w') as fw:
            fw.write(self.combineDocument())


# print(os.path.realpath(__file__))
if len(sys.argv) < 2:
    print('Usage: MarkTeX <input mtex file>.')
    sys.exit(1)

# Print start message.
print('MarkTeX ' + VERSION)

if not sys.argv[0].endswith('/MarkTeX'):
    print('You\'ve renamed the application...')
print('Input file - ' + sys.argv[1] + ':')

if not os.path.isfile(sys.argv[1]):
    print(sys.argv[1] + ' does not exist.')
    sys.exit(2)

mtx = MarkTex()
doc = LatexDocument(sys.argv[1], mtx)
doc.readFrontMatter()

doc.writeVariables()
doc.writeContent()
print('EOP---------------------------')
print(doc.combineDocument())
doc.writeDocument()
